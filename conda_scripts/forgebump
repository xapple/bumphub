#!/usr/bin/env python3
# -*- coding: utf8 -*-

"""
A script to automatically submit a package to conda-forge.
See the README.md file for more information.

Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
"""

# Built-in modules #
import sys, tomllib, inspect, hashlib
from string import Template
from urllib.parse import urlparse
from urllib.request import urlopen

# Internal modules #
from __init__ import get_args

# Third party modules #
import sh
from autopaths import Path

# Constants #
__version__ = '0.9.0'
pypi_url = "https://pypi.org/packages/source/"

# Get command line arguments #
doc = sys.modules[__name__].__doc__
base_dir, proj_name, code_dir, toml_path, test_mode = get_args(doc)

# We need to make sure that all executables are available #
gh = sh.Command('gh')
git = sh.Command('git')

# Print start #
print("Packaging '%s' for conda-forge submission." % proj_name)
print("---------------------------")

###############################################################################
# Parse the pyproject.toml file #
toml_data = tomllib.loads(toml_path.contents)
project = toml_data.get("project", {})

# Extract info from TOML dictionary #
github_url = toml_data["project"]["urls"]["Homepage"]
user = urlparse(github_url).path.split("/")[1]
version = toml_data["project"]["version"]
gz_url = pypi_url + f"{proj_name[0]}/{proj_name}/{proj_name}-{version}.tar.gz"
summary = toml_data["project"]["description"].replace("'", "''")

# Compute the SHA256 checksum #
sha256 = hashlib.sha256(urlopen(gz_url).read()).hexdigest()

# These are hardcoded, but it could be interesting to auto-detect in the future #
license_spdx = "MIT"
license_family = "MIT"
license_file = "LICENSE.txt"

# All the variables for the template #
recipe_dict = {
    "name_lower":     proj_name,
    "version":        version,
    "source_url":     gz_url,
    "sha256":         sha256,
    "home":           github_url,
    "summary":        summary,
    "license":        license_spdx,
    "license_family": license_family,
    "license_file":   license_file,
    "maintainer":     user,
}

###############################################################################
# Fork the main repo on GitHub (will skip if already forked) #
staged_name = 'conda-forge/staged-recipes'
args = ['repo', 'fork', staged_name, '--clone=false']
print("Checking that '%s' is forked." % staged_name)
gh(*args, _out=sys.stdout, _err=sys.stderr)

# Now check we have a cloned copy of the repo (about 200MB) #
staged_repo = Path("~/repos/staged-recipes/").expanduser()
if not staged_repo.exists():
    url = 'git@github.com:xapple/staged-recipes.git'
    print("Cloning '%s' to '%s'." % (url, staged_repo))
    args = ['clone', url, staged_repo]
    git(*args, _out=sys.stdout, _err=sys.stderr)

# Change directory to the cloned repo #
with sh.pushd(str(staged_repo)):
    # Get the current branch #
    branch_name = f"add-{proj_name}"
    current_branch = git("rev-parse", "--abbrev-ref", "HEAD").strip()

    # Create a branch #
    if branch_name != current_branch: git.checkout("-b", branch_name)

    # Create a recipe directory #
    recipe_dir = staged_repo + "recipes/" + proj_name + "/"
    recipe_dir.create_if_not_exists()

    # Path to the template and path to the output file #
    template = Path((inspect.stack()[0])[1]).directory  + "template.yaml"
    meta_path = recipe_dir + "meta.yaml"

    # Write it #
    meta_path.write(Template(template.contents).substitute(recipe_dict))

    # Git add / commit / push #
    git.add(recipe_dir)
    git.commit("-m", f"Add {proj_name}")
    git.push("-u", "origin", branch_name)

    # create PR
    gh(
        "pr", "create",
        "--repo",  "conda-forge/staged-recipes",
        "--title", f"Add python package `{proj_name}` to staged-recipes.",
        "--body",  f"Adding `{proj_name}` from PyPI for distribution on conda-forge.",
        "--head",  f"{user}:{branch_name}"
    )

    # Print exit message #
    msg = f"""
    The PR has been created on GitHub at:
    https://github.com/conda-forge/staged-recipes/pull/new/{branch_name}
    Once the PR is ready for review, please mention one of the teams above
    in a new comment. i.e. `@conda-forge/help-python, ready for review!
    Due to GitHub limitations, first time contributors to conda-forge are unable
    to ping conda-forge teams directly, but you can ask a bot to ping the team:

    @conda-forge-admin, please ping team
    """
    print(msg)
