#!/usr/bin/env python3
# -*- coding: utf8 -*-

"""
A script to automatically update python modules on anaconda using rattler.
See the README.md file for more information.

Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
"""

# Built-in modules #
import os, sys
from pathlib import Path as Pathlib

# First party modules #
from __init__                 import parse_common_args
from plumbing.check_cmd_found import check_cmd

# Third party modules #
import sh
from pyrattler_recipe_autogen.core import generate_recipe_with_config
from pyrattler_recipe_autogen.core import OutputConfig

# Constants #
__version__ = '0.9.0'

args, base_dir, module_name, code_dir, toml_path, test_mode = parse_common_args(
    sys.modules[__name__].__doc__
)

# We need to make sure that all executables are available #
check_cmd('rattler-build')

###############################################################################
# Autogenerate the recipe #
print("---------------------------")
print("-> Autogenerating rattler-build recipe")

# Create a temporary directory #
build_dir = base_dir + 'build/'
build_dir.create_if_not_exists()
recipe_path = build_dir + 'recipe.yaml'

# Generate recipe via the Python API so we can exclude sections.
generate_recipe_with_config(
    pyproject_path=Pathlib(toml_path),
    output_path=Pathlib(recipe_path),
    config=OutputConfig(exclude_sections=["optional_dependencies", "optional_dep_groups"])
)

# But the problem is that "pyrattler-recipe-autogen" generates a recipe.yaml
# that is not accepted by "rattler-build" because of this part:
#   × expected a scalar value.
#  [build/recipe.yaml:31:11]
#  optional_dependencies:
#  ╭─▶     binary:
#  │       - binaryornot
#  │       external:
#  │       - pbs3
#  │       - sh
#  ├─▶ package:
#  ╰──── here

###############################################################################
# Build #
print("---------------------------")
print("-> Building package")

# Get the executable #
rattler_build = sh.Command('rattler-build')

# Launch command:
# `rattler-build build -r recipe.yaml -c conda-forge -c xapple -c bioconda`
try:
    rattler_build('build',
                   '-r', str(recipe_path),
                   '-c', 'conda-forge',
                   '-c', 'xapple',
                   '-c', 'bioconda',
                   '--experimental',
                   '--output-dir', str(build_dir),
                   _out=sys.stdout,
                   _err=sys.stderr)
except sh.ErrorReturnCode as e:
    if e.stdout:
        print('-' * 60)
        msg = "Here is the stdout:"
        print(msg, e.stdout.decode('utf-8'))
    if e.stderr:
        print('-' * 60)
        msg = "Here is the stderr:"
        print(msg, e.stderr.decode('utf-8'))
    print('-' * 60)
    raise

# Get the path of the resulting package files #
artifacts = []
for root, _, files in os.walk(str(build_dir)):
    for fname in files:
        if fname.endswith(('.conda', '.tar.bz2')):
            artifacts.append(os.path.join(root, fname))
msg = "No package artifacts found in build outputs."
assert len(artifacts) > 0, msg
artifacts.sort(key=os.path.getmtime)
tar_path = artifacts[-1]

# Report the path #
print("---------------------------")
print("-> Tar path found: %s" % tar_path)

###############################################################################
# Upload #
print("---------------------------")
print("-> Uploading package")

# This uses ANACONDA_API_KEY or the keychain / auth-file.
upload_args = ['upload', 'anaconda', '--owner', 'xapple',
               '--channel', 'xapple', tar_path]
upload = rattler_build(*upload_args, _out=sys.stdout, _err=sys.stderr)

# Optional message #
if hasattr(upload, 'stderr') and upload.stderr:
    print(str(upload.stderr, "UTF-8"))

# Done #
print("Success.")