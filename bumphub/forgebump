#!/usr/bin/env python3
# -*- coding: utf8 -*-

"""
A script to automatically submit a package to conda-forge.
See the README.md file for more information.

Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
"""

# Built-in modules #
import sys, tomllib, inspect, hashlib, re
from string import Template
from urllib.parse import urlparse
from urllib.request import urlopen

# Internal modules #
from __init__ import get_args

# Third party modules #
import sh
from autopaths import Path

# Constants #
__version__ = '0.9.0'
pypi_url = "https://pypi.org/packages/source/"

# Get command line arguments #
doc = sys.modules[__name__].__doc__
base_dir, proj_name, code_dir, toml_path, test_mode = get_args(doc)

# We need to make sure that all executables are available #
gh = sh.Command('gh')
git = sh.Command('git')

# Print start #
print("Packaging '%s' for conda-forge submission." % proj_name)
print("---------------------------")

###############################################################################
# Parse the pyproject.toml file #
toml_data = tomllib.loads(toml_path.contents)
project = toml_data.get("project", {})

# Extract info from TOML dictionary #
github_url = toml_data["project"]["urls"]["Homepage"]
user = urlparse(github_url).path.split("/")[1]
version = toml_data["project"]["version"]
gz_url = pypi_url + f"{proj_name[0]}/{proj_name}/{proj_name}-{version}.tar.gz"
summary = toml_data["project"]["description"].replace("'", "''")
python_min = toml_data["project"]["requires-python"].replace(">=", "")

# The dependency parsing is a bit trickier #
# Because "proj>=1.6.2 must contain a space i.e., proj >=1.6.2"
fix_pin = lambda dep: re.sub(r"([A-Za-z0-9_.-]+)([<>=!~]=?)", r"\1 \2", dep)
run_deps = ["    - " + fix_pin(dep.split(";", 1)[0].strip())
            for dep in project.get("dependencies", [])
            if dep and not dep.startswith("python")]

# Compute the SHA256 checksum #
sha256 = hashlib.sha256(urlopen(gz_url).read()).hexdigest()

# These are hardcoded, but it could be interesting to auto-detect
# in the future
license_spdx = "MIT"
license_family = "MIT"
license_file = "LICENSE.txt"

# All the variables for the template #
recipe_dict = {
    "name_lower":     proj_name,
    "version":        version,
    "source_url":     gz_url,
    "sha256":         sha256,
    "home":           github_url,
    "summary":        summary,
    "license":        license_spdx,
    "license_family": license_family,
    "license_file":   license_file,
    "maintainer":     user,
    "python_min":     python_min,
    "run_deps":       '\n'.join(run_deps),
}

# Path to the template and path to the output file #
template = Path((inspect.stack()[0])[1]).directory + "template.yaml"

# Make the meta.yaml recipe content #
yaml_out = Template(template.contents).substitute(recipe_dict)

###############################################################################
# Fork the main repo on GitHub (will skip if already forked) #
staged_name = 'conda-forge/staged-recipes'
args = ['repo', 'fork', staged_name, '--clone=false']
print("Checking that '%s' is forked." % staged_name)
gh(*args, _out=sys.stdout, _err=sys.stderr)

# Now check we have a cloned copy of the repo (about 200MB) #
staged_repo = Path("~/repos/staged-recipes/")
if not staged_repo.exists:
    url = 'git@github.com:xapple/staged-recipes.git'
    print("Cloning '%s' to '%s'." % (url, staged_repo))
    args = ['clone', url, staged_repo]
    git(*args, _out=sys.stdout, _err=sys.stderr)

# Change directory to the cloned repo #
with sh.pushd(str(staged_repo)):
    # Ensure the main branch is up to date with upstream before branching #
    git.fetch("upstream", "main")

    # Get the current branch #
    branch_name    = f"add-{proj_name}"
    current_branch = git("rev-parse", "--abbrev-ref", "HEAD").strip()
    already_exists = git("branch", "--list", branch_name).strip()

    # Create or reuse a branch from the main branch with a hard reset #
    if branch_name != current_branch:
        if already_exists: git.checkout(branch_name)
        else:
            git.checkout("main")
            git.reset("--hard", "upstream/main")
            git.checkout("-b", branch_name)

    # Create a recipe directory and write it #
    recipe_dir = staged_repo + "recipes/" + proj_name + "/"
    recipe_dir.create_if_not_exists()
    meta_path = recipe_dir + "meta.yaml"
    meta_path.write(yaml_out)

    # Git add / commit / push #
    git.add(recipe_dir)
    git.commit("-m", f"Add {proj_name}")
    git.push("-u", "origin", branch_name)

    # Create PR #
    body = f"Adding `{proj_name}` from PyPI for distribution on conda-forge."
    pr_url = gh(
        "pr", "create",
        "--repo",  "conda-forge/staged-recipes",
        "--title", f"Add python package `{proj_name}` to staged-recipes.",
        "--body",  body,
        "--head",  f"{user}:{branch_name}",
    )

    # Print exit message #
    msg = f"""
    The PR has been created on GitHub at:
    {pr_url}
    Once the PR is ready for review, please mention one of the teams above
    in a new comment. i.e. `@conda-forge/help-python, ready for review!`
    Due to GitHub limitations, first time contributors to conda-forge are unable
    to ping conda-forge teams directly, but you can ask a bot to ping the team:

        @conda-forge-admin, please ping team
    """
    print(msg)